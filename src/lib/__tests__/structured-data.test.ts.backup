import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

// Use vi.hoisted to ensure proper mock setup
const { mockGetTranslations, mockGenerateCanonicalURL } = vi.hoisted(() => ({
  mockGetTranslations: vi.fn(),
  mockGenerateCanonicalURL: vi.fn(),
}));

vi.mock('next-intl/server', () => ({
  getTranslations: mockGetTranslations,
}));

vi.mock('@/services/url-generator', () => ({
  generateCanonicalURL: mockGenerateCanonicalURL,
}));

vi.mock('@/lib/i18n-performance', () => ({
  I18nPerformanceMonitor: {
    getInstance: () => ({
      trackTranslationUsage: vi.fn(),
    }),
    recordError: vi.fn(),
  },
}));

vi.mock('@/i18n/routing', () => ({
  routing: {
    locales: ['en', 'zh'],
    defaultLocale: 'en',
  },
}));

vi.mock('@/config/paths', () => ({
  SITE_CONFIG: {
    name: 'Tucsenberg',
    description: 'Modern Enterprise Platform',
    baseUrl: 'https://tucsenberg.com',
    author: 'Tucsenberg Team',
    social: {
      twitter: '@tucsenberg',
      linkedin: 'company/tucsenberg',
    },
  },
}));

// Import after mocks
import {
    createArticleStructuredData,
    createBreadcrumbStructuredData,
    generateJSONLD,
    generateLocalizedStructuredData,
} from '../structured-data';

describe('Structured Data Generation', () => {
  beforeEach(() => {
    vi.clearAllMocks();

    // Mock translation function
    const mockT = vi.fn((key: string, options?: { defaultValue?: string }) => {
      const translations: Record<string, string> = {
        'organization.name': 'Tucsenberg',
        'organization.description': 'Modern Enterprise Platform',
        'website.name': 'Tucsenberg',
        'website.description': 'Enterprise Solutions',
        'breadcrumb.home': 'Home',
        'breadcrumb.about': 'About',
        'breadcrumb.contact': 'Contact',
        'article.author': 'Tucsenberg Team',
        'product.brand': 'Tucsenberg',
        'faq.question1': 'What is Tucsenberg?',
        'faq.answer1': 'A modern enterprise platform',
        'business.name': 'Tucsenberg Inc.',
        'business.address': '123 Business St, City, Country',
        'business.phone': '+1-234-567-8900',
      };
      return translations[key] || options?.defaultValue || key;
    });

    mockGetTranslations.mockResolvedValue(mockT);
    mockGenerateCanonicalURL.mockReturnValue('https://tucsenberg.com/test');
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('generateLocalizedStructuredData', () => {
    it('should generate organization structured data', async () => {
      const orgData = {
        name: 'Test Organization',
        description: 'Test Description',
        url: 'https://test.com',
        logo: 'https://test.com/logo.png',
      };

      const schema = await generateLocalizedStructuredData('en', 'Organization', orgData);

      expect(schema).toBeDefined();
      expect(schema['@context']).toBe('https://schema.org');
      expect(schema['@type']).toBe('Organization');
      expect(mockGetTranslations).toHaveBeenCalledWith({
        locale: 'en',
        namespace: 'structured-data',
      });
    });

    it('should generate website structured data', async () => {
      const websiteData = {
        name: 'Test Website',
        description: 'Test Website Description',
        url: 'https://test.com',
      };

      const schema = await generateLocalizedStructuredData('zh', 'WebSite', websiteData);

      expect(schema).toBeDefined();
      expect(schema['@context']).toBe('https://schema.org');
      expect(schema['@type']).toBe('WebSite');
      expect(mockGetTranslations).toHaveBeenCalledWith({
        locale: 'zh',
        namespace: 'structured-data',
      });
    });

    it('should generate article structured data', async () => {
      const articleData = {
        title: 'Test Article',
        description: 'Test Article Description',
        author: 'Test Author',
        publishedTime: '2023-01-01T00:00:00Z',
        url: 'https://test.com/article',
      };

      const schema = await generateLocalizedStructuredData('en', 'Article', articleData);

      expect(schema).toBeDefined();
      expect(schema['@context']).toBe('https://schema.org');
      expect(schema['@type']).toBe('Article');
    });

    it('should generate product structured data', async () => {
      const productData = {
        name: 'Test Product',
        description: 'Test Product Description',
        price: '99.99',
        currency: 'USD',
        availability: 'InStock',
      };

      const schema = await generateLocalizedStructuredData('en', 'Product', productData);

      expect(schema).toBeDefined();
      expect(schema['@context']).toBe('https://schema.org');
      expect(schema['@type']).toBe('Product');
    });

    it('should generate breadcrumb structured data', async () => {
      const breadcrumbData = {
        items: [
          { name: 'Home', url: 'https://test.com/', position: 1 },
          { name: 'About', url: 'https://test.com/about', position: 2 },
        ],
      };

      const schema = await generateLocalizedStructuredData('en', 'BreadcrumbList', breadcrumbData);

      expect(schema).toBeDefined();
      expect(schema['@context']).toBe('https://schema.org');
      expect(schema['@type']).toBe('BreadcrumbList');
    });

    it('should handle translation errors gracefully', async () => {
      mockGetTranslations.mockRejectedValue(new Error('Translation error'));

      const result = await generateLocalizedStructuredData('en', 'Organization', { name: 'Test' });

      // Should return basic structure when translation fails
      expect(result).toEqual({
        '@context': 'https://schema.org',
        '@type': 'Organization',
      });
    });
  });

  describe('generateJSONLD', () => {
    it('should generate valid JSON-LD string', () => {
      const testData = {
        '@context': 'https://schema.org',
        '@type': 'Organization',
        name: 'Test Organization',
      };

      const jsonLD = generateJSONLD(testData);

      expect(jsonLD).toBe(JSON.stringify(testData, null, 2));
      expect(() => JSON.parse(jsonLD)).not.toThrow();
    });

    it('should handle complex nested objects', () => {
      const complexData = {
        '@context': 'https://schema.org',
        '@type': 'Article',
        author: {
          '@type': 'Person',
          name: 'John Doe',
        },
        publisher: {
          '@type': 'Organization',
          name: 'Test Publisher',
          logo: {
            '@type': 'ImageObject',
            url: 'https://test.com/logo.png',
          },
        },
      };

      const jsonLD = generateJSONLD(complexData);

      expect(() => JSON.parse(jsonLD)).not.toThrow();
      const parsed = JSON.parse(jsonLD);
      expect(parsed.author.name).toBe('John Doe');
      expect(parsed.publisher.logo.url).toBe('https://test.com/logo.png');
    });

    it('should handle null and undefined values', () => {
      const dataWithNulls = {
        '@context': 'https://schema.org',
        '@type': 'Organization',
        name: 'Test',
        description: null,
        logo: undefined,
      };

      const jsonLD = generateJSONLD(dataWithNulls);

      expect(() => JSON.parse(jsonLD)).not.toThrow();
      const parsed = JSON.parse(jsonLD);
      expect(parsed.description).toBeNull();
      expect(parsed.logo).toBeUndefined();
    });
  });

  describe('createBreadcrumbStructuredData', () => {
    it('should create breadcrumb structured data', async () => {
      const breadcrumbs = [
        { name: 'Home', url: 'https://test.com/' },
        { name: 'About', url: 'https://test.com/about' },
        { name: 'Contact', url: 'https://test.com/contact' },
      ];

      const result = await createBreadcrumbStructuredData('en', breadcrumbs);

      expect(result).toBeDefined();
      expect(mockGetTranslations).toHaveBeenCalledWith({
        locale: 'en',
        namespace: 'structured-data',
      });
    });

    it('should handle empty breadcrumbs array', async () => {
      const result = await createBreadcrumbStructuredData('zh', []);

      expect(result).toBeDefined();
      expect(mockGetTranslations).toHaveBeenCalledWith({
        locale: 'zh',
        namespace: 'structured-data',
      });
    });
  });

  describe('createArticleStructuredData', () => {
    it('should create article structured data', async () => {
      const articleData = {
        title: 'Test Article',
        description: 'Test Description',
        author: 'Test Author',
        publishedTime: '2023-01-01T00:00:00Z',
        modifiedTime: '2023-01-02T00:00:00Z',
        url: 'https://test.com/article',
        image: 'https://test.com/image.jpg',
      };

      const result = await createArticleStructuredData('en', articleData);

      expect(result).toBeDefined();
      expect(mockGetTranslations).toHaveBeenCalledWith({
        locale: 'en',
        namespace: 'structured-data',
      });
    });

    it('should handle missing optional fields', async () => {
      const articleData = {
        title: 'Test Article',
        description: 'Test Description',
        publishedTime: '2023-01-01T00:00:00Z',
        url: 'https://test.com/article',
      };

      const result = await createArticleStructuredData('zh', articleData);

      expect(result).toBeDefined();
      expect(mockGetTranslations).toHaveBeenCalledWith({
        locale: 'zh',
        namespace: 'structured-data',
      });
    });
  });

  describe('error handling and edge cases', () => {
    it('should handle invalid structured data types', async () => {
      const result = await generateLocalizedStructuredData('en', 'InvalidType' as any, {});

      expect(result).toBeDefined();
      expect(result['@context']).toBe('https://schema.org');
      expect(result['@type']).toBe('InvalidType');
    });

    it('should handle empty data objects', async () => {
      const result = await generateLocalizedStructuredData('en', 'Organization', {});

      expect(result).toBeDefined();
      expect(result['@context']).toBe('https://schema.org');
      expect(result['@type']).toBe('Organization');
    });

    it('should handle different locales consistently', async () => {
      const testData = { name: 'Test' };

      const enResult = await generateLocalizedStructuredData('en', 'Organization', testData);
      const zhResult = await generateLocalizedStructuredData('zh', 'Organization', testData);

      expect(enResult['@context']).toBe(zhResult['@context']);
      expect(enResult['@type']).toBe(zhResult['@type']);
    });
  });
});
