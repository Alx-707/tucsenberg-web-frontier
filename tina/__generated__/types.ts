// TinaSDK generated code
import { createClient, TinaClient } from 'tinacms/dist/client';

//@ts-nocheck
// DO NOT MODIFY THIS FILE. This file is automatically generated by Tina
export function gql(strings: TemplateStringsArray, ...args: string[]): string {
  let str = '';
  strings.forEach((string, i) => {
    str += string + (args[i] || '');
  });
  return str;
}
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type MakeEmpty<
  T extends { [key: string]: unknown },
  K extends keyof T,
> = { [_ in K]?: never };
export type Incremental<T> =
  | T
  | {
      [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never;
    };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string };
  String: { input: string; output: string };
  Boolean: { input: boolean; output: boolean };
  Int: { input: number; output: number };
  Float: { input: number; output: number };
  /** References another document, used as a foreign key */
  Reference: { input: any; output: any };
  JSON: { input: any; output: any };
};

export type SystemInfo = {
  __typename?: 'SystemInfo';
  filename: Scalars['String']['output'];
  title?: Maybe<Scalars['String']['output']>;
  basename: Scalars['String']['output'];
  hasReferences?: Maybe<Scalars['Boolean']['output']>;
  breadcrumbs: Array<Scalars['String']['output']>;
  path: Scalars['String']['output'];
  relativePath: Scalars['String']['output'];
  extension: Scalars['String']['output'];
  template: Scalars['String']['output'];
  collection: Collection;
};

export type SystemInfoBreadcrumbsArgs = {
  excludeExtension?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Folder = {
  __typename?: 'Folder';
  name: Scalars['String']['output'];
  path: Scalars['String']['output'];
};

export type PageInfo = {
  __typename?: 'PageInfo';
  hasPreviousPage: Scalars['Boolean']['output'];
  hasNextPage: Scalars['Boolean']['output'];
  startCursor: Scalars['String']['output'];
  endCursor: Scalars['String']['output'];
};

export type Node = {
  id: Scalars['ID']['output'];
};

export type Document = {
  id: Scalars['ID']['output'];
  _sys?: Maybe<SystemInfo>;
  _values: Scalars['JSON']['output'];
};

/** A relay-compliant pagination connection */
export type Connection = {
  totalCount: Scalars['Float']['output'];
  pageInfo: PageInfo;
};

export type Query = {
  __typename?: 'Query';
  getOptimizedQuery?: Maybe<Scalars['String']['output']>;
  collection: Collection;
  collections: Array<Collection>;
  node: Node;
  document: DocumentNode;
  posts: Posts;
  postsConnection: PostsConnection;
  pages: Pages;
  pagesConnection: PagesConnection;
};

export type QueryGetOptimizedQueryArgs = {
  queryString: Scalars['String']['input'];
};

export type QueryCollectionArgs = {
  collection?: InputMaybe<Scalars['String']['input']>;
};

export type QueryNodeArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
};

export type QueryDocumentArgs = {
  collection?: InputMaybe<Scalars['String']['input']>;
  relativePath?: InputMaybe<Scalars['String']['input']>;
};

export type QueryPostsArgs = {
  relativePath?: InputMaybe<Scalars['String']['input']>;
};

export type QueryPostsConnectionArgs = {
  before?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Float']['input']>;
  last?: InputMaybe<Scalars['Float']['input']>;
  sort?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<PostsFilter>;
};

export type QueryPagesArgs = {
  relativePath?: InputMaybe<Scalars['String']['input']>;
};

export type QueryPagesConnectionArgs = {
  before?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Float']['input']>;
  last?: InputMaybe<Scalars['Float']['input']>;
  sort?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<PagesFilter>;
};

export type DocumentFilter = {
  posts?: InputMaybe<PostsFilter>;
  pages?: InputMaybe<PagesFilter>;
};

export type DocumentConnectionEdges = {
  __typename?: 'DocumentConnectionEdges';
  cursor: Scalars['String']['output'];
  node?: Maybe<DocumentNode>;
};

export type DocumentConnection = Connection & {
  __typename?: 'DocumentConnection';
  pageInfo: PageInfo;
  totalCount: Scalars['Float']['output'];
  edges?: Maybe<Array<Maybe<DocumentConnectionEdges>>>;
};

export type Collection = {
  __typename?: 'Collection';
  name: Scalars['String']['output'];
  slug: Scalars['String']['output'];
  label?: Maybe<Scalars['String']['output']>;
  path: Scalars['String']['output'];
  format?: Maybe<Scalars['String']['output']>;
  matches?: Maybe<Scalars['String']['output']>;
  templates?: Maybe<Array<Maybe<Scalars['JSON']['output']>>>;
  fields?: Maybe<Array<Maybe<Scalars['JSON']['output']>>>;
  documents: DocumentConnection;
};

export type CollectionDocumentsArgs = {
  before?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Float']['input']>;
  last?: InputMaybe<Scalars['Float']['input']>;
  sort?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<DocumentFilter>;
  folder?: InputMaybe<Scalars['String']['input']>;
};

export type DocumentNode = Posts | Pages | Folder;

export type PostsSeo = {
  __typename?: 'PostsSeo';
  title?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  keywords?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  ogImage?: Maybe<Scalars['String']['output']>;
};

export type Posts = Node &
  Document & {
    __typename?: 'Posts';
    locale: Scalars['String']['output'];
    title: Scalars['String']['output'];
    description: Scalars['String']['output'];
    slug: Scalars['String']['output'];
    publishedAt: Scalars['String']['output'];
    updatedAt?: Maybe<Scalars['String']['output']>;
    author: Scalars['String']['output'];
    tags?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    categories?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
    featured?: Maybe<Scalars['Boolean']['output']>;
    draft?: Maybe<Scalars['Boolean']['output']>;
    excerpt?: Maybe<Scalars['String']['output']>;
    readingTime?: Maybe<Scalars['Float']['output']>;
    coverImage?: Maybe<Scalars['String']['output']>;
    seo?: Maybe<PostsSeo>;
    body?: Maybe<Scalars['JSON']['output']>;
    id: Scalars['ID']['output'];
    _sys: SystemInfo;
    _values: Scalars['JSON']['output'];
  };

export type StringFilter = {
  startsWith?: InputMaybe<Scalars['String']['input']>;
  eq?: InputMaybe<Scalars['String']['input']>;
  exists?: InputMaybe<Scalars['Boolean']['input']>;
  in?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type DatetimeFilter = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  eq?: InputMaybe<Scalars['String']['input']>;
  exists?: InputMaybe<Scalars['Boolean']['input']>;
  in?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type BooleanFilter = {
  eq?: InputMaybe<Scalars['Boolean']['input']>;
  exists?: InputMaybe<Scalars['Boolean']['input']>;
};

export type NumberFilter = {
  lt?: InputMaybe<Scalars['Float']['input']>;
  lte?: InputMaybe<Scalars['Float']['input']>;
  gte?: InputMaybe<Scalars['Float']['input']>;
  gt?: InputMaybe<Scalars['Float']['input']>;
  eq?: InputMaybe<Scalars['Float']['input']>;
  exists?: InputMaybe<Scalars['Boolean']['input']>;
  in?: InputMaybe<Array<InputMaybe<Scalars['Float']['input']>>>;
};

export type ImageFilter = {
  startsWith?: InputMaybe<Scalars['String']['input']>;
  eq?: InputMaybe<Scalars['String']['input']>;
  exists?: InputMaybe<Scalars['Boolean']['input']>;
  in?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type PostsSeoFilter = {
  title?: InputMaybe<StringFilter>;
  description?: InputMaybe<StringFilter>;
  keywords?: InputMaybe<StringFilter>;
  ogImage?: InputMaybe<ImageFilter>;
};

export type PostsBodyCodeBlockFilter = {
  language?: InputMaybe<StringFilter>;
  code?: InputMaybe<StringFilter>;
};

export type RichTextFilter = {
  startsWith?: InputMaybe<Scalars['String']['input']>;
  eq?: InputMaybe<Scalars['String']['input']>;
  exists?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PostsBodyCalloutFilter = {
  type?: InputMaybe<StringFilter>;
  title?: InputMaybe<StringFilter>;
  content?: InputMaybe<RichTextFilter>;
};

export type PostsBodyFilter = {
  CodeBlock?: InputMaybe<PostsBodyCodeBlockFilter>;
  Callout?: InputMaybe<PostsBodyCalloutFilter>;
};

export type PostsFilter = {
  locale?: InputMaybe<StringFilter>;
  title?: InputMaybe<StringFilter>;
  description?: InputMaybe<StringFilter>;
  slug?: InputMaybe<StringFilter>;
  publishedAt?: InputMaybe<DatetimeFilter>;
  updatedAt?: InputMaybe<DatetimeFilter>;
  author?: InputMaybe<StringFilter>;
  tags?: InputMaybe<StringFilter>;
  categories?: InputMaybe<StringFilter>;
  featured?: InputMaybe<BooleanFilter>;
  draft?: InputMaybe<BooleanFilter>;
  excerpt?: InputMaybe<StringFilter>;
  readingTime?: InputMaybe<NumberFilter>;
  coverImage?: InputMaybe<ImageFilter>;
  seo?: InputMaybe<PostsSeoFilter>;
  body?: InputMaybe<PostsBodyFilter>;
};

export type PostsConnectionEdges = {
  __typename?: 'PostsConnectionEdges';
  cursor: Scalars['String']['output'];
  node?: Maybe<Posts>;
};

export type PostsConnection = Connection & {
  __typename?: 'PostsConnection';
  pageInfo: PageInfo;
  totalCount: Scalars['Float']['output'];
  edges?: Maybe<Array<Maybe<PostsConnectionEdges>>>;
};

export type PagesSeo = {
  __typename?: 'PagesSeo';
  title?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  keywords?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  ogImage?: Maybe<Scalars['String']['output']>;
};

export type Pages = Node &
  Document & {
    __typename?: 'Pages';
    locale: Scalars['String']['output'];
    title: Scalars['String']['output'];
    description: Scalars['String']['output'];
    slug: Scalars['String']['output'];
    publishedAt?: Maybe<Scalars['String']['output']>;
    updatedAt?: Maybe<Scalars['String']['output']>;
    author: Scalars['String']['output'];
    layout?: Maybe<Scalars['String']['output']>;
    showToc?: Maybe<Scalars['Boolean']['output']>;
    lastReviewed?: Maybe<Scalars['String']['output']>;
    draft?: Maybe<Scalars['Boolean']['output']>;
    seo?: Maybe<PagesSeo>;
    body?: Maybe<Scalars['JSON']['output']>;
    id: Scalars['ID']['output'];
    _sys: SystemInfo;
    _values: Scalars['JSON']['output'];
  };

export type PagesSeoFilter = {
  title?: InputMaybe<StringFilter>;
  description?: InputMaybe<StringFilter>;
  keywords?: InputMaybe<StringFilter>;
  ogImage?: InputMaybe<ImageFilter>;
};

export type PagesFilter = {
  locale?: InputMaybe<StringFilter>;
  title?: InputMaybe<StringFilter>;
  description?: InputMaybe<StringFilter>;
  slug?: InputMaybe<StringFilter>;
  publishedAt?: InputMaybe<DatetimeFilter>;
  updatedAt?: InputMaybe<DatetimeFilter>;
  author?: InputMaybe<StringFilter>;
  layout?: InputMaybe<StringFilter>;
  showToc?: InputMaybe<BooleanFilter>;
  lastReviewed?: InputMaybe<DatetimeFilter>;
  draft?: InputMaybe<BooleanFilter>;
  seo?: InputMaybe<PagesSeoFilter>;
  body?: InputMaybe<RichTextFilter>;
};

export type PagesConnectionEdges = {
  __typename?: 'PagesConnectionEdges';
  cursor: Scalars['String']['output'];
  node?: Maybe<Pages>;
};

export type PagesConnection = Connection & {
  __typename?: 'PagesConnection';
  pageInfo: PageInfo;
  totalCount: Scalars['Float']['output'];
  edges?: Maybe<Array<Maybe<PagesConnectionEdges>>>;
};

export type Mutation = {
  __typename?: 'Mutation';
  addPendingDocument: DocumentNode;
  updateDocument: DocumentNode;
  deleteDocument: DocumentNode;
  createDocument: DocumentNode;
  createFolder: DocumentNode;
  updatePosts: Posts;
  createPosts: Posts;
  updatePages: Pages;
  createPages: Pages;
};

export type MutationAddPendingDocumentArgs = {
  collection: Scalars['String']['input'];
  relativePath: Scalars['String']['input'];
  template?: InputMaybe<Scalars['String']['input']>;
};

export type MutationUpdateDocumentArgs = {
  collection?: InputMaybe<Scalars['String']['input']>;
  relativePath: Scalars['String']['input'];
  params: DocumentUpdateMutation;
};

export type MutationDeleteDocumentArgs = {
  collection?: InputMaybe<Scalars['String']['input']>;
  relativePath: Scalars['String']['input'];
};

export type MutationCreateDocumentArgs = {
  collection?: InputMaybe<Scalars['String']['input']>;
  relativePath: Scalars['String']['input'];
  params: DocumentMutation;
};

export type MutationCreateFolderArgs = {
  collection?: InputMaybe<Scalars['String']['input']>;
  relativePath: Scalars['String']['input'];
};

export type MutationUpdatePostsArgs = {
  relativePath: Scalars['String']['input'];
  params: PostsMutation;
};

export type MutationCreatePostsArgs = {
  relativePath: Scalars['String']['input'];
  params: PostsMutation;
};

export type MutationUpdatePagesArgs = {
  relativePath: Scalars['String']['input'];
  params: PagesMutation;
};

export type MutationCreatePagesArgs = {
  relativePath: Scalars['String']['input'];
  params: PagesMutation;
};

export type DocumentUpdateMutation = {
  posts?: InputMaybe<PostsMutation>;
  pages?: InputMaybe<PagesMutation>;
  relativePath?: InputMaybe<Scalars['String']['input']>;
};

export type DocumentMutation = {
  posts?: InputMaybe<PostsMutation>;
  pages?: InputMaybe<PagesMutation>;
};

export type PostsSeoMutation = {
  title?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  keywords?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  ogImage?: InputMaybe<Scalars['String']['input']>;
};

export type PostsMutation = {
  locale?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
  publishedAt?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['String']['input']>;
  author?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  categories?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  featured?: InputMaybe<Scalars['Boolean']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  excerpt?: InputMaybe<Scalars['String']['input']>;
  readingTime?: InputMaybe<Scalars['Float']['input']>;
  coverImage?: InputMaybe<Scalars['String']['input']>;
  seo?: InputMaybe<PostsSeoMutation>;
  body?: InputMaybe<Scalars['JSON']['input']>;
};

export type PagesSeoMutation = {
  title?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  keywords?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  ogImage?: InputMaybe<Scalars['String']['input']>;
};

export type PagesMutation = {
  locale?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  slug?: InputMaybe<Scalars['String']['input']>;
  publishedAt?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['String']['input']>;
  author?: InputMaybe<Scalars['String']['input']>;
  layout?: InputMaybe<Scalars['String']['input']>;
  showToc?: InputMaybe<Scalars['Boolean']['input']>;
  lastReviewed?: InputMaybe<Scalars['String']['input']>;
  draft?: InputMaybe<Scalars['Boolean']['input']>;
  seo?: InputMaybe<PagesSeoMutation>;
  body?: InputMaybe<Scalars['JSON']['input']>;
};

export type PostsPartsFragment = {
  __typename: 'Posts';
  locale: string;
  title: string;
  description: string;
  slug: string;
  publishedAt: string;
  updatedAt?: string | null;
  author: string;
  tags?: Array<string | null> | null;
  categories?: Array<string | null> | null;
  featured?: boolean | null;
  draft?: boolean | null;
  excerpt?: string | null;
  readingTime?: number | null;
  coverImage?: string | null;
  body?: any | null;
  seo?: {
    __typename: 'PostsSeo';
    title?: string | null;
    description?: string | null;
    keywords?: Array<string | null> | null;
    ogImage?: string | null;
  } | null;
};

export type PagesPartsFragment = {
  __typename: 'Pages';
  locale: string;
  title: string;
  description: string;
  slug: string;
  publishedAt?: string | null;
  updatedAt?: string | null;
  author: string;
  layout?: string | null;
  showToc?: boolean | null;
  lastReviewed?: string | null;
  draft?: boolean | null;
  body?: any | null;
  seo?: {
    __typename: 'PagesSeo';
    title?: string | null;
    description?: string | null;
    keywords?: Array<string | null> | null;
    ogImage?: string | null;
  } | null;
};

export type PostsQueryVariables = Exact<{
  relativePath: Scalars['String']['input'];
}>;

export type PostsQuery = {
  __typename?: 'Query';
  posts: {
    __typename: 'Posts';
    id: string;
    locale: string;
    title: string;
    description: string;
    slug: string;
    publishedAt: string;
    updatedAt?: string | null;
    author: string;
    tags?: Array<string | null> | null;
    categories?: Array<string | null> | null;
    featured?: boolean | null;
    draft?: boolean | null;
    excerpt?: string | null;
    readingTime?: number | null;
    coverImage?: string | null;
    body?: any | null;
    _sys: {
      __typename?: 'SystemInfo';
      filename: string;
      basename: string;
      hasReferences?: boolean | null;
      breadcrumbs: Array<string>;
      path: string;
      relativePath: string;
      extension: string;
    };
    seo?: {
      __typename: 'PostsSeo';
      title?: string | null;
      description?: string | null;
      keywords?: Array<string | null> | null;
      ogImage?: string | null;
    } | null;
  };
};

export type PostsConnectionQueryVariables = Exact<{
  before?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Float']['input']>;
  last?: InputMaybe<Scalars['Float']['input']>;
  sort?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<PostsFilter>;
}>;

export type PostsConnectionQuery = {
  __typename?: 'Query';
  postsConnection: {
    __typename?: 'PostsConnection';
    totalCount: number;
    pageInfo: {
      __typename?: 'PageInfo';
      hasPreviousPage: boolean;
      hasNextPage: boolean;
      startCursor: string;
      endCursor: string;
    };
    edges?: Array<{
      __typename?: 'PostsConnectionEdges';
      cursor: string;
      node?: {
        __typename: 'Posts';
        id: string;
        locale: string;
        title: string;
        description: string;
        slug: string;
        publishedAt: string;
        updatedAt?: string | null;
        author: string;
        tags?: Array<string | null> | null;
        categories?: Array<string | null> | null;
        featured?: boolean | null;
        draft?: boolean | null;
        excerpt?: string | null;
        readingTime?: number | null;
        coverImage?: string | null;
        body?: any | null;
        _sys: {
          __typename?: 'SystemInfo';
          filename: string;
          basename: string;
          hasReferences?: boolean | null;
          breadcrumbs: Array<string>;
          path: string;
          relativePath: string;
          extension: string;
        };
        seo?: {
          __typename: 'PostsSeo';
          title?: string | null;
          description?: string | null;
          keywords?: Array<string | null> | null;
          ogImage?: string | null;
        } | null;
      } | null;
    } | null> | null;
  };
};

export type PagesQueryVariables = Exact<{
  relativePath: Scalars['String']['input'];
}>;

export type PagesQuery = {
  __typename?: 'Query';
  pages: {
    __typename: 'Pages';
    id: string;
    locale: string;
    title: string;
    description: string;
    slug: string;
    publishedAt?: string | null;
    updatedAt?: string | null;
    author: string;
    layout?: string | null;
    showToc?: boolean | null;
    lastReviewed?: string | null;
    draft?: boolean | null;
    body?: any | null;
    _sys: {
      __typename?: 'SystemInfo';
      filename: string;
      basename: string;
      hasReferences?: boolean | null;
      breadcrumbs: Array<string>;
      path: string;
      relativePath: string;
      extension: string;
    };
    seo?: {
      __typename: 'PagesSeo';
      title?: string | null;
      description?: string | null;
      keywords?: Array<string | null> | null;
      ogImage?: string | null;
    } | null;
  };
};

export type PagesConnectionQueryVariables = Exact<{
  before?: InputMaybe<Scalars['String']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Float']['input']>;
  last?: InputMaybe<Scalars['Float']['input']>;
  sort?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<PagesFilter>;
}>;

export type PagesConnectionQuery = {
  __typename?: 'Query';
  pagesConnection: {
    __typename?: 'PagesConnection';
    totalCount: number;
    pageInfo: {
      __typename?: 'PageInfo';
      hasPreviousPage: boolean;
      hasNextPage: boolean;
      startCursor: string;
      endCursor: string;
    };
    edges?: Array<{
      __typename?: 'PagesConnectionEdges';
      cursor: string;
      node?: {
        __typename: 'Pages';
        id: string;
        locale: string;
        title: string;
        description: string;
        slug: string;
        publishedAt?: string | null;
        updatedAt?: string | null;
        author: string;
        layout?: string | null;
        showToc?: boolean | null;
        lastReviewed?: string | null;
        draft?: boolean | null;
        body?: any | null;
        _sys: {
          __typename?: 'SystemInfo';
          filename: string;
          basename: string;
          hasReferences?: boolean | null;
          breadcrumbs: Array<string>;
          path: string;
          relativePath: string;
          extension: string;
        };
        seo?: {
          __typename: 'PagesSeo';
          title?: string | null;
          description?: string | null;
          keywords?: Array<string | null> | null;
          ogImage?: string | null;
        } | null;
      } | null;
    } | null> | null;
  };
};

export const PostsPartsFragmentDoc = gql`
  fragment PostsParts on Posts {
    __typename
    locale
    title
    description
    slug
    publishedAt
    updatedAt
    author
    tags
    categories
    featured
    draft
    excerpt
    readingTime
    coverImage
    seo {
      __typename
      title
      description
      keywords
      ogImage
    }
    body
  }
`;
export const PagesPartsFragmentDoc = gql`
  fragment PagesParts on Pages {
    __typename
    locale
    title
    description
    slug
    publishedAt
    updatedAt
    author
    layout
    showToc
    lastReviewed
    draft
    seo {
      __typename
      title
      description
      keywords
      ogImage
    }
    body
  }
`;
export const PostsDocument = gql`
  query posts($relativePath: String!) {
    posts(relativePath: $relativePath) {
      ... on Document {
        _sys {
          filename
          basename
          hasReferences
          breadcrumbs
          path
          relativePath
          extension
        }
        id
      }
      ...PostsParts
    }
  }
  ${PostsPartsFragmentDoc}
`;
export const PostsConnectionDocument = gql`
  query postsConnection(
    $before: String
    $after: String
    $first: Float
    $last: Float
    $sort: String
    $filter: PostsFilter
  ) {
    postsConnection(
      before: $before
      after: $after
      first: $first
      last: $last
      sort: $sort
      filter: $filter
    ) {
      pageInfo {
        hasPreviousPage
        hasNextPage
        startCursor
        endCursor
      }
      totalCount
      edges {
        cursor
        node {
          ... on Document {
            _sys {
              filename
              basename
              hasReferences
              breadcrumbs
              path
              relativePath
              extension
            }
            id
          }
          ...PostsParts
        }
      }
    }
  }
  ${PostsPartsFragmentDoc}
`;
export const PagesDocument = gql`
  query pages($relativePath: String!) {
    pages(relativePath: $relativePath) {
      ... on Document {
        _sys {
          filename
          basename
          hasReferences
          breadcrumbs
          path
          relativePath
          extension
        }
        id
      }
      ...PagesParts
    }
  }
  ${PagesPartsFragmentDoc}
`;
export const PagesConnectionDocument = gql`
  query pagesConnection(
    $before: String
    $after: String
    $first: Float
    $last: Float
    $sort: String
    $filter: PagesFilter
  ) {
    pagesConnection(
      before: $before
      after: $after
      first: $first
      last: $last
      sort: $sort
      filter: $filter
    ) {
      pageInfo {
        hasPreviousPage
        hasNextPage
        startCursor
        endCursor
      }
      totalCount
      edges {
        cursor
        node {
          ... on Document {
            _sys {
              filename
              basename
              hasReferences
              breadcrumbs
              path
              relativePath
              extension
            }
            id
          }
          ...PagesParts
        }
      }
    }
  }
  ${PagesPartsFragmentDoc}
`;
export type Requester<C = {}> = <R, V>(
  doc: DocumentNode,
  vars?: V,
  options?: C,
) => Promise<R>;
export function getSdk<C>(requester: Requester<C>) {
  return {
    posts(
      variables: PostsQueryVariables,
      options?: C,
    ): Promise<{
      data: PostsQuery;
      errors?: {
        message: string;
        locations: { line: number; column: number }[];
        path: string[];
      }[];
      variables: PostsQueryVariables;
      query: string;
    }> {
      return requester<
        {
          data: PostsQuery;
          errors?: {
            message: string;
            locations: { line: number; column: number }[];
            path: string[];
          }[];
          variables: PostsQueryVariables;
          query: string;
        },
        PostsQueryVariables
      >(PostsDocument, variables, options);
    },
    postsConnection(
      variables?: PostsConnectionQueryVariables,
      options?: C,
    ): Promise<{
      data: PostsConnectionQuery;
      errors?: {
        message: string;
        locations: { line: number; column: number }[];
        path: string[];
      }[];
      variables: PostsConnectionQueryVariables;
      query: string;
    }> {
      return requester<
        {
          data: PostsConnectionQuery;
          errors?: {
            message: string;
            locations: { line: number; column: number }[];
            path: string[];
          }[];
          variables: PostsConnectionQueryVariables;
          query: string;
        },
        PostsConnectionQueryVariables
      >(PostsConnectionDocument, variables, options);
    },
    pages(
      variables: PagesQueryVariables,
      options?: C,
    ): Promise<{
      data: PagesQuery;
      errors?: {
        message: string;
        locations: { line: number; column: number }[];
        path: string[];
      }[];
      variables: PagesQueryVariables;
      query: string;
    }> {
      return requester<
        {
          data: PagesQuery;
          errors?: {
            message: string;
            locations: { line: number; column: number }[];
            path: string[];
          }[];
          variables: PagesQueryVariables;
          query: string;
        },
        PagesQueryVariables
      >(PagesDocument, variables, options);
    },
    pagesConnection(
      variables?: PagesConnectionQueryVariables,
      options?: C,
    ): Promise<{
      data: PagesConnectionQuery;
      errors?: {
        message: string;
        locations: { line: number; column: number }[];
        path: string[];
      }[];
      variables: PagesConnectionQueryVariables;
      query: string;
    }> {
      return requester<
        {
          data: PagesConnectionQuery;
          errors?: {
            message: string;
            locations: { line: number; column: number }[];
            path: string[];
          }[];
          variables: PagesConnectionQueryVariables;
          query: string;
        },
        PagesConnectionQueryVariables
      >(PagesConnectionDocument, variables, options);
    },
  };
}
export type Sdk = ReturnType<typeof getSdk>;

const generateRequester = (client: TinaClient) => {
  const requester: (
    doc: any,
    vars?: any,
    options?: {
      branch?: string;
      /**
       * Aside from `method` and `body`, all fetch options are passed
       * through to underlying fetch request
       */
      fetchOptions?: Omit<Parameters<typeof fetch>[1], 'body' | 'method'>;
    },
    client,
  ) => Promise<any> = async (doc, vars, options) => {
    let url = client.apiUrl;
    if (options?.branch) {
      const index = client.apiUrl.lastIndexOf('/');
      url = client.apiUrl.substring(0, index + 1) + options.branch;
    }
    const data = await client.request(
      {
        query: doc,
        variables: vars,
        url,
      },
      options,
    );

    return {
      data: data?.data,
      errors: data?.errors,
      query: doc,
      variables: vars || {},
    };
  };

  return requester;
};

/**
 * @experimental this class can be used but may change in the future
 **/
export const ExperimentalGetTinaClient = () =>
  getSdk(
    generateRequester(
      createClient({
        url: 'http://localhost:4001/graphql',
        queries,
      }),
    ),
  );

export const queries = (client: TinaClient) => {
  const requester = generateRequester(client);
  return getSdk(requester);
};
